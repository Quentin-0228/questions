## HTML5

### 1、HTML5 的新特性？

- 1、语义化标签，比如 header、footer、nav、aside、article、section
- 2、音视频，比如 audio、video
- 3、画布 canvas、矢量图 svg
- 3、画布，canvas 的 api 有 getContext、fillStyle、fillRect 等
- 4、本地存储 localStorage、sessionStorage
- 5、web worker

### 2、语义化的好处？

- 1、开发时：代码分块清晰，便于维护
- 2、开发时：页面结构清晰，便于浏览器。搜索引擎解析
- 3、上线后：利于搜索引擎的爬取，利于 SEO

### 3、canvas 的常用 api 有哪些？

- getContext：返回一个指定 canvas 的绘画环境对象
- beginPath：开始绘制
- moveTo：移动画笔位置
- lineTo：用来画线段
- stroke：用来实施绘制的操作
- lineStyle：设置线段的样式
- closePath：结束绘制

### 4、web worker 有什么作用？应用场景有哪些？

开启一个子线程，且子线程的操作不受线程的影响

- 大数据处理
- 耗费时间较长的操作

### 5、浏览器本地缓存 localStorage 与 sessionStorage 的区别？

- 生命周期不同：前者一直存在浏览器，除非用户手动清除，后者生命周期结束于浏览器或者 tab 页的关闭

## CSS3

### 1、有哪些新特性呢？

flex、animation、transform、border-radius、box-shadow、opacity

### 2、背景毛玻璃的效果如何实现呢？

filter：blur()

### 3、position 有哪几种呢？

- static：默认
- relative：相对于自身
- absolute：相对于最近的一个非 static 的祖先级元素进行定位
- fixed：相对于屏幕窗口进行定位
- sticky：用来实现吸顶效果

### 4、如何自己实现跟 position：sticky 的效果？

使用 getBoundingClientRect 或者 IntersectionObserver 计算指定元素位置，到达一定距离更改指定元素定位为 fixed，从而实现 sticky 的效果

### 5、重绘回流是什么呢？

[文章链接](https://juejin.cn/post/6986416221323264030)

### 6、怎么降低重绘回流的次数呢？

[文章链接](https://juejin.cn/post/6986416221323264030)

### 7、flex 布局如何更改主轴方向？

设置 flex-direction 样式属性

### 8、flex 布局如何允许换行呢？

设置 flex-wrap 样式属性

### 9、flex 布局实现水平垂直据居中？

设置 justify-content 和 align-items 都为 center

### 10、flex：1 的原理是什么呢？

flex-grow 、flex-shrink 、flex-basis 这三个样式的合集，全写状态为 flex:0 1 auto，简写为 flex: 1

### 11、rem 与 em 的区别是什么呢？

- rem：相对于<html>标签的 font-size 去决定大小，例如 html 标签 font-size 为 14px，则 2rem === 28px
- em：相对于自身的 font-size 去决定大小，自身没有 font-size 则继承祖先级元素的 font-size

## JavaScript

### 1、原型链是什么呢？有什么作用吗

- 原型链：原型链是一条对象隐式原型不断往上指向的一条指向链，尽头是 Object 的隐式原型，也就是 null
- 作用：构造函数原型上的东西可以让实例们共享，从而节省了空间

### 2、闭包是什么？有什么优缺点

闭包是一个能让函数外部访问到函数内部的一个函数

- 优点是：延长函数内部变量的寿命，使函数外部能访问到函数内部
- 缺点是：滥用闭包导致内存溢出，页面卡顿

### 3、JavaScript 总共有几种数据类型？

字符串、布尔值、数值、undefined、null、object、symbol、bigInt

### 4、JavaScript 判断类型的方式是什么？

- typeof：只能判断 字符串、布尔值、数值、undefined、function、object、symbol、bigInt，不能区分判断 数组、null、对象
- A instanceof B：判断 A 是否为 B 的实例对象，从而判断 A 是否为 B 类型
- Object.prototype.toString.call()：可以判断所有的数据类型

### 6、JavaScript 不同类型的存储方式有何区别？

普遍认为

- 基础数据类型存于栈内存
- 引用数据类型存于堆内存
  我认为
- 所有数据都存于堆内存，栈内存只存指针

### 7、你说字符串存储在栈内存，那如果字符串很长。超过了栈内存最大容量呢？

所以说我觉得所有数据都存于堆内存，毕竟栈内存容量有限。

### 8、call、apply、bind 的区别？

- call 于 apply 的区别在于传参，前者直接传参，后者传一个数组
- bind 传参后不立即执行，而是会返回一个函数，这个函数可以继续传参，且执行（bind 函数可以分两次传参）

### 9、bind 返回的函数能作为构造函数吗？

不能哦，会报错的

### 10、赋值、深拷贝与浅拷贝有什么不同？

- 赋值：赋值指针指向，还是用的同一个内存空间
- 浅拷贝：只拷贝第一层
- 深拷贝：所有层都会进行拷贝

### 11、怎么判断一个对象有环引用呢？

定义一个空数组，且对于目标对象进行递归，每次都判断递归项是否为对象，是的话放进数组，且每次判断属性值是否在数组里，在的话说明环引用了

```js
function cycleDetector(obj) {
	const arr = [obj];
	let flag = false;

	function cycle(o) {
		const keys = Object.keys(o);
		for (const key of keys) {
			const temp = o[key];
			if (typeof temp === 'object' && temp !== null) {
				if (arr.indexOf(temp) >= 0) {
					flag = true;
					return;
				}
				arr.push(temp);
				cycle(temp);
			}
		}
	}

	cycle(obj);

	return flag;
}
```

## ES6

### 1、let、const 的暂时性死区问题？

在一个作用域里如果存在 let、const 定义的一个变量之前使用该变量，则报错“cannot access xx before initialization”

### 2、Promise 的 then 为什么可以链式调用？

Promise 的 then 方法返回一个新的 Promise 对象，保证了 then 方法可以进行链式调用

### 3、async/await 的用法？

- async/await 的作用是：以同步的方式执行异步操作，实现排队效果
- async：async 函数执行返回一个 Promise
- await：await 后接 Promise 则会等待 Promise 返回结果，接普通函数执行则会接收返回结果
- await 只能在 async 中使用，但是浏览器调试中 await 可单独使用

### 4、Class 的静态属性、继承？

- 静态属性：static 关键字定义的变量属性，只能通过 Class 构造函数的属性的方式去访问
- 继承：使用 Child extends Father {}，且配合 super 对象，完成继承

## Vue

### Vue 数据双向绑定原理？

Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持
各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

- 1、需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter，这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化

- 2、compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每
  个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

- 3、Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
  3.1）在自身实例化时往属性订阅器(dep)里面添加自己
  3.2）自身必须有一个 update()方法
  3.3）待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中
  绑定的回调，则功成身退。

- 4、MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通 Observer 来监
  听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer
  和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model
  变更的双向绑定效果

### 1、Vue 与 React 的区别在哪？

比较的是 Vue2
相同点：

- 1.都使用了虚拟 dom
- 2.组件化开发
- 3.都是单向数据流(父子组件之间，不建议子修改父传下来的数据)
- 4.都支持服务端渲染
  不同点：
- 1.React 的 JSX，Vue 的 template
- 2.数据变化，React 手动(setState)，Vue 自动(初始化已响应式处理，Object.defineProperty，Proxy)
- 3.React 单向绑定，Vue 双向绑定
- 4.React 的 Redux、mobx，Vue 的 Vuex、pinia

### 2、computed 与 watch 的区别？

- computed：多对一，多个值的变化决定一个目标值的变化
- watch：一对多，一个值的变化，引起多个目标值的变化

### 3、Vue 的生命周期介绍一下？

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892fde0e56324868921d0e924c84858a~tplv-k3u1fbpfcp-watermark.image)

### 4、Vue 的实例加载完成在哪个生命周期呢？

beforeCreated

### 5、Vue 的真实 dom 挂载完成在哪个生命周期呢？

mounted

### 6、数据更改如何获取最新 DOM

nextTick

### 7、路由有几种模式，有何区别？

- hash 模式：监听 url 中 hash 的变化来实现不同页面的展示，链接带#
- history 模式：url 中不带#，利用 HTML5 的 history.pushState 方法进行不刷新跳转页面，但需要后端配合 404 时的重定向
- abstract：使用在非浏览器的环境，例如 node 环境

### 8、路由有哪些钩子函数？

全局钩子

- beforeEach：跳转路由前
  - to：将要跳转进入的路由对象
  - from：将要离开的路由对象
  - next：一个方法，执行则完成跳转
- afterEach：跳转路由后
  - to：将要跳转进入的路由对象

路由独享钩子

```js
routes: [
	{
		path: '/xxx',
		component: xxx,
		beforeEnter: (to, from, next) => {},
	},
];
```

组件内路由钩子

- beforeRouteEnter(to, from, next)：跳转路由渲染组件时触发
- beforeRouteUpdate(to, from, next)：跳转路由且组件被复用时触发
- beforeRouteLeave(to, from, next)：跳转路由且离开组件时出触发

初级前端工程师直播
